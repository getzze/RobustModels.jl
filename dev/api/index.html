<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · RobustModels</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://getzze.github.io/RobustModels.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RobustModels</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types-defined-in-the-package"><span>Types defined in the package</span></a></li><li><a class="tocitem" href="#Constructors-for-models"><span>Constructors for models</span></a></li><li><a class="tocitem" href="#Model-methods"><span>Model methods</span></a></li><li><a class="tocitem" href="#Estimators"><span>Estimators</span></a></li><li><a class="tocitem" href="#Loss-functions"><span>Loss functions</span></a></li><li><a class="tocitem" href="#Estimator-and-Loss-functions-methods"><span>Estimator and Loss functions methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/getzze/RobustModels.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Types-defined-in-the-package"><a class="docs-heading-anchor" href="#Types-defined-in-the-package">Types defined in the package</a><a id="Types-defined-in-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Types-defined-in-the-package" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobustModels.AbstractRobustModel" href="#RobustModels.AbstractRobustModel"><code>RobustModels.AbstractRobustModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRobustModel</code></pre><p>Abstract type for robust models.</p><p><code>RobustModels.jl</code> implements one subtype: <a href="#RobustModels.RobustLinearModel"><code>RobustLinearModel</code></a>. See the documentation for each for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/RobustModels.jl#L145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.AbstractEstimator" href="#RobustModels.AbstractEstimator"><code>RobustModels.AbstractEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A robust estimator is a location or scale estimator associated to one (or more) loss function and solved using Iteratively Reweighted Least Square.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/RobustModels.jl#L135-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.AbstractQuantileEstimator" href="#RobustModels.AbstractQuantileEstimator"><code>RobustModels.AbstractQuantileEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Generalized M-Quantile estimator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/RobustModels.jl#L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.LossFunction" href="#RobustModels.LossFunction"><code>RobustModels.LossFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An estimator needs a cost/loss function for the modified (weighted) least squares problems of the form:</p><p class="math-container">\[\min \sum_i \rho\left(\dfrac{r_i}{\hat{\sigma}}ight)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/RobustModels.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.RobustLinearModel" href="#RobustModels.RobustLinearModel"><code>RobustModels.RobustLinearModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RobustLinearModel</code></pre><p>Robust linear model representation</p><p><strong>Fields</strong></p><ul><li><code>resp</code>: the <a href="#RobustModels.RobustLinResp"><code>RobustLinResp</code></a> structure.</li><li><code>pred</code>: the predictor structure, of type <a href="#GLM.DensePredChol"><code>DensePredChol</code></a>, <a href="#GLM.SparsePredChol"><code>SparsePredChol</code></a>, <a href="#RobustModels.DensePredCG"><code>DensePredCG</code></a>, <a href="#RobustModels.SparsePredCG"><code>SparsePredCG</code></a> or <a href="#RobustModels.RidgePred"><code>RidgePred</code></a>.</li><li><code>fitdispersion</code>: if true, the dispersion is estimated otherwise it is kept fixed</li><li><code>fitted</code>: if true, the model was already fitted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L26-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.DensePredCG" href="#RobustModels.DensePredCG"><code>RobustModels.DensePredCG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensePredCG</code></pre><p>A <code>LinPred</code> type with Conjugate Gradient and a dense <code>X</code></p><p><strong>Members</strong></p><ul><li><code>X</code>: Model matrix of size <code>n</code> × <code>p</code> with <code>n ≥ p</code>.  Should be full column rank.</li><li><code>beta0</code>: base coefficient vector of length <code>p</code></li><li><code>delbeta</code>: increment to coefficient vector, also of length <code>p</code></li><li><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <a href="@ref"><code>linpred!</code></a> method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/linpred.jl#L99-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.SparsePredCG" href="#RobustModels.SparsePredCG"><code>RobustModels.SparsePredCG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparsePredCG</code></pre><p>A <code>LinPred</code> type with Conjugate Gradient and a sparse <code>X</code></p><p><strong>Members</strong></p><ul><li><code>X</code>: Model matrix of size <code>n</code> × <code>p</code> with <code>n ≥ p</code>.  Should be full column rank.</li><li><code>beta0</code>: base coefficient vector of length <code>p</code></li><li><code>delbeta</code>: increment to coefficient vector, also of length <code>p</code></li><li><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <a href="@ref"><code>linpred!</code></a> method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/linpred.jl#L163-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GLM.DensePredChol" href="#GLM.DensePredChol"><code>GLM.DensePredChol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensePredChol{T}</code></pre><p>A <code>LinPred</code> type with a dense Cholesky factorization of <code>X&#39;X</code></p><p><strong>Members</strong></p><ul><li><code>X</code>: model matrix of size <code>n</code> × <code>p</code> with <code>n ≥ p</code>.  Should be full column rank.</li><li><code>beta0</code>: base coefficient vector of length <code>p</code></li><li><code>delbeta</code>: increment to coefficient vector, also of length <code>p</code></li><li><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <code>linpred!</code> method</li><li><code>chol</code>: a <code>Cholesky</code> object created from <code>X&#39;X</code>, possibly using row weights.</li><li><code>scratchm1</code>: scratch Matrix{T} of the same size as <code>X</code></li><li><code>scratchm2</code>: scratch Matrix{T} os the same size as <code>X&#39;X</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GLM.SparsePredChol" href="#GLM.SparsePredChol"><code>GLM.SparsePredChol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparsePredChol{T&lt;:BlasReal} &lt;: LinPred</code></pre><p>A LinPred type with a sparse Cholesky factorization of X&#39;X</p><p><strong>Members</strong></p><ul><li><code>X</code>: model matrix of size n×p with n ≥ p. Should be full column rank.</li><li><code>beta0</code>: base coefficient vector of length p</li><li><code>delbeta</code>: increment to coefficient vector, also of length p</li><li><code>scratchbeta</code>: scratch vector of length p, used in <a href="@ref"><code>linpred!</code></a> method</li><li><code>chol</code>: a Cholesky object created from X&#39;X, possibly using row weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/linpred.jl#L82-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.RidgePred" href="#RobustModels.RidgePred"><code>RobustModels.RidgePred</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RidgePred</code></pre><p>Regularized predictor using ridge regression on the <code>p</code> features.</p><p><strong>Members</strong></p><ul><li><code>X</code>: model matrix</li><li><code>λ</code>: shrinkage parameter of the regularizer</li><li><code>G</code>: regularizer matrix of size p×p.</li><li><code>βprior</code>: regularizer prior of the coefficient values. Default to <code>zeros(p)</code>.</li><li><code>pred</code>: the non-regularized predictor using an extended model matrix.</li><li><code>pivot</code>: for <code>DensePredChol</code>, if the decomposition was pivoted.</li><li><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <a href="@ref"><code>linpred!</code></a> method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/linpred.jl#L239-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.RobustLinResp" href="#RobustModels.RobustLinResp"><code>RobustModels.RobustLinResp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RobustLinResp</code></pre><p>Robust linear response structure.</p><p>Solve the following minimization problem:</p><p class="math-container">\[\min \sum_i \rho\left(\dfrac{r_i}{\hat{\sigma}}ight)\]</p><p><strong>Fields</strong></p><ul><li><code>est</code>: estimator used for the model</li><li><code>y</code>: response vector</li><li><code>μ</code>: mean response vector</li><li><code>offset</code>: offset added to <code>Xβ</code> to form <code>μ</code>. Can be of length 0</li><li><code>wts</code>: prior case weights.  Can be of length 0.</li><li><code>σ</code>: current estimate of the scale or dispersion</li><li><code>devresid</code>: the deviance residuals</li><li><code>wrkwt</code>: working case weights for the Iteratively Reweighted Least Squares (IRLS) algorithm</li><li><code>wrkres</code>: working residuals for IRLS</li><li><code>wrkscaledres</code>: scaled residuals for IRLS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/linresp.jl#L9-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.QuantileRegression" href="#RobustModels.QuantileRegression"><code>RobustModels.QuantileRegression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantileRegression</code></pre><p>Quantile regression representation</p><p><strong>Fields</strong></p><ul><li><code>τ</code>: the quantile value</li><li><code>X</code>: the model matrix</li><li><code>β</code>: the coefficients</li><li><code>y</code>: the response vector</li><li><code>wts</code>: the weights</li><li><code>wrkres</code>: the working residuals</li><li><code>fitdispersion</code>: if true, the dispersion is estimated otherwise it is kept fixed</li><li><code>fitted</code>: if true, the model was already fitted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/quantileregression.jl#L6-L21">source</a></section></article><h2 id="Constructors-for-models"><a class="docs-heading-anchor" href="#Constructors-for-models">Constructors for models</a><a id="Constructors-for-models-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-for-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{M}, AbstractMatrix{T}, AbstractVector{T}, AbstractEstimator}} where {T&lt;:AbstractFloat, M&lt;:RobustLinearModel}" href="#StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{M}, AbstractMatrix{T}, AbstractVector{T}, AbstractEstimator}} where {T&lt;:AbstractFloat, M&lt;:RobustLinearModel}"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit(::Type{M},
    X::Union{AbstractMatrix{T},SparseMatrixCSC{T}},
    y::AbstractVector{T},
    est::Estimator;
    method::Symbol       = :chol, # :cg
    dofit::Bool          = true,
    wts::FPVector        = similar(y, 0),
    offset::FPVector     = similar(y, 0),
    fitdispersion::Bool  = false,
    ridgeλ::Real         = 0,
    ridgeG::Union{UniformScaling, AbstractArray} = I,
    βprior::AbstractVector = [],
    quantile::Union{Nothing, AbstractFloat} = nothing,
    initial_scale::Union{Symbol, Real}=:mad,
    σ0::Union{Nothing, Symbol, Real}=initial_scale,
    initial_coef::AbstractVector=[],
    β0::AbstractVector=initial_coef,
    correct_leverage::Bool=false
    fitargs...) where {M&lt;:RobustLinearModel, T&lt;:AbstractFloat}</code></pre><p>Create a robust model with the model matrix (or formula) X and response vector (or dataframe) y, using a robust estimator.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: the model matrix (it can be dense or sparse) or a formula</li><li><code>y</code>: the response vector or a dataframe.</li><li><code>est</code>: a robust estimator</li></ul><p><strong>Keywords</strong></p><ul><li><code>method::Symbol = :chol</code>: the method to use for solving the weighted linear system, <code>chol</code> (default) or <code>cg</code>;</li><li><code>dofit::Bool = true</code>: if false, return the model object without fitting;</li><li><code>wts::Vector = []</code>: a weight vector, should be empty if no weights are used;</li><li><code>offset::Vector = []</code>: an offset vector, should be empty if no offset is used;</li><li><code>fitdispersion::Bool = false</code>: reevaluate the dispersion;</li><li><code>ridgeλ::Real = 0</code>: if positive, perform a robust ridge regression with shrinkage parameter <code>ridgeλ</code>. <a href="#RobustModels.RidgePred"><code>RidgePred</code></a> object will be used;</li><li><code>ridgeG::Union{UniformScaling, AbstractArray} = I</code>: define a custom regularization matrix. Default to unity matrix (with 0 for the intercept);</li><li><code>βprior::AbstractVector = []</code>: define a custom prior for the coefficients for ridge regression. Default to <code>zeros(p)</code>;</li><li><code>quantile::Union{Nothing, AbstractFloat} = nothing</code>: only for <a href="#RobustModels.GeneralizedQuantileEstimator"><code>GeneralizedQuantileEstimator</code></a>, define the quantile to estimate;</li><li><code>initial_scale::Union{Symbol, Real}=:mad</code>: the initial scale estimate, for non-convex estimator it helps to find the global minimum. Automatic computation using <code>:mad</code>, <code>L1</code> or <code>extrema</code> (non-robust).</li><li><code>σ0::Union{Nothing, Symbol, Real}=initial_scale</code>: alias of <code>initial_scale</code>;</li><li><code>initial_coef::AbstractVector=[]</code>: the initial coefficients estimate, for non-convex estimator it helps to find the global minimum.</li><li><code>β0::AbstractVector=initial_coef</code>: alias of <code>initial_coef</code>;</li><li><code>correct_leverage::Bool=false</code>: apply the leverage correction weights with <a href="@ref"><code>leverage_weights</code></a>.</li><li><code>fitargs...</code>: other keyword arguments used to control the convergence of the IRLS algorithm (see <a href="@ref"><code>pirls!</code></a>).</li></ul><p><strong>Output</strong></p><p>the RobustLinearModel object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L221-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{M}, AbstractMatrix{T}, AbstractVector{T}}} where {T&lt;:AbstractFloat, M&lt;:QuantileRegression}" href="#StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{M}, AbstractMatrix{T}, AbstractVector{T}}} where {T&lt;:AbstractFloat, M&lt;:QuantileRegression}"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit(::Type{M}, X::Union{AbstractMatrix{T},SparseMatrixCSC{T}},
    y::AbstractVector{T}; quantile::AbstractFloat=0.5,
    dofit::Bool          = true,
    wts::FPVector        = similar(y, 0),
    fitdispersion::Bool  = false,
    fitargs...) where {M&lt;:QuantileRegression, T&lt;:AbstractFloat}</code></pre><p>Fit a quantile regression model with the model matrix (or formula) X and response vector (or dataframe) y.</p><p>It is solved using the exact interior method.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: the model matrix (it can be dense or sparse) or a formula</li><li><code>y</code>: the response vector or a dataframe.</li></ul><p><strong>Keywords</strong></p><ul><li><code>quantile::AbstractFloat=0.5</code>: the quantile value for the regression, between 0 and 1.</li><li><code>dofit::Bool = true</code>: if <code>false</code>, return the model object without fitting;</li><li><code>wts::Vector = []</code>: a weight vector, should be empty if no weights are used;</li><li><code>fitdispersion::Bool = false</code>: reevaluate the dispersion;</li><li><code>fitargs...</code>: other keyword arguments like <code>verbose</code> to print iteration details.</li></ul><p><strong>Output</strong></p><p>the RobustLinearModel object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/quantileregression.jl#L79-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.rlm" href="#RobustModels.rlm"><code>RobustModels.rlm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rlm(X, y, args...; kwargs...)</code></pre><p>An alias for <code>fit(RobustLinearModel, X, y, est; kwargs...)</code>.</p><p>The arguments <code>X</code> and <code>y</code> can be a <code>Matrix</code> and a <code>Vector</code> or a <code>Formula</code> and a <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.quantreg" href="#RobustModels.quantreg"><code>RobustModels.quantreg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quantreg(X, y, args...; kwargs...)</code></pre><p>An alias for <code>fit(QuantileRegression, X, y; kwargs...)</code>.</p><p>The arguments <code>X</code> and <code>y</code> can be a <code>Matrix</code> and a <code>Vector</code> or a <code>Formula</code> and a <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/quantileregression.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit!" href="#StatsBase.fit!"><code>StatsBase.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(m::RobustLinearModel; initial_scale::Union{Symbol, Real}=:mad,
          σ0::Union{Nothing, Symbol, Real}=initial_scale,
          initial_coef::AbstractVector=[],
          β0::AbstractVector=initial_coef,
          correct_leverage::Bool=false, kwargs...)</code></pre><p>Optimize the objective of a <code>RobustLinearModel</code>.  When <code>verbose</code> is <code>true</code> the values of the objective and the parameters are printed on stdout at each iteration.</p><p>This function assumes that <code>m</code> was correctly initialized.</p><p>This function returns early if the model was already fitted, instead call <code>refit!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L452-L465">source</a></section><section><div><pre><code class="nohighlight hljs">fit!(m::QuantileRegression;
     verbose::Bool=false,
     quantile::Union{Nothing, AbstractFloat}=nothing,
     correct_leverage::Bool=false,
     kwargs...)</code></pre><p>Optimize the objective of a <code>QuantileRegression</code>.  When <code>verbose</code> is <code>true</code> the values of the objective and the parameters are printed on stdout at each function evaluation.</p><p>This function assumes that <code>m</code> was correctly initialized. This function returns early if the model was already fitted, instead call <code>refit!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/quantileregression.jl#L195-L207">source</a></section><section><div><p>Fit a statistical model in-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.refit!" href="#RobustModels.refit!"><code>RobustModels.refit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refit!(m::RobustLinearModel, [y::FPVector];
                             wts::Union{Nothing, FPVector} = nothing,
                             offset::Union{Nothing, FPVector} = nothing,
                             quantile::Union{Nothing, AbstractFloat} = nothing,
                             ridgeλ::Union{Nothing, Real} = nothing,
                             kwargs...)</code></pre><p>Refit the <a href="#RobustModels.RobustLinearModel"><code>RobustLinearModel</code></a>.</p><p>This function assumes that <code>m</code> was correctly initialized and the model is refitted with the new values for the response, weights, offset, quantile and ridge shrinkage.</p><p>Defining a new <code>quantile</code> is only possible for <a href="#RobustModels.GeneralizedQuantileEstimator"><code>GeneralizedQuantileEstimator</code></a>.</p><p>Defining a new <code>ridgeλ</code> is only possible for <a href="#RobustModels.RidgePred"><code>RidgePred</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L358-L374">source</a></section><section><div><pre><code class="nohighlight hljs">refit!(m::QuantileRegression,
      [y::FPVector ;
       verbose::Bool=false,
       quantile::Union{Nothing,
       AbstractFloat}=nothing,
      ]
)</code></pre><p>Refit the <code>QuantileRegression</code> model with the new values for the response, weights and quantile. This function assumes that <code>m</code> was correctly initialized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/quantileregression.jl#L144-L155">source</a></section></article><h2 id="Model-methods"><a class="docs-heading-anchor" href="#Model-methods">Model methods</a><a id="Model-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Model-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsBase.coef" href="#StatsBase.coef"><code>StatsBase.coef</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coef(model::StatisticalModel)</code></pre><p>Return the coefficients of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.coeftable" href="#StatsBase.coeftable"><code>StatsBase.coeftable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coeftable(model::StatisticalModel; level::Real=0.95)</code></pre><p>Return a table with coefficients and related statistics of the model. <code>level</code> determines the level for confidence intervals (by default, 95%).</p><p>The returned <code>CoefTable</code> object implements the <a href="https://github.com/JuliaData/Tables.jl/">Tables.jl</a> interface, and can be converted e.g. to a <code>DataFrame</code> via <code>using DataFrames; DataFrame(coeftable(model))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.confint" href="#StatsBase.confint"><code>StatsBase.confint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">confint(model::StatisticalModel; level::Real=0.95)</code></pre><p>Compute confidence intervals for coefficients, with confidence level <code>level</code> (by default 95%).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.deviance" href="#StatsBase.deviance"><code>StatsBase.deviance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deviance(obj::LinearModel)</code></pre><p>For linear models, the deviance is equal to the residual sum of squares (RSS).</p></div></section><section><div><pre><code class="nohighlight hljs">deviance(m::RobustLinearModel)</code></pre><p>The sum of twice the loss/objective applied to the scaled residuals.</p><p>It is consistent with the definition of the deviance for OLS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L111-L117">source</a></section><section><div><pre><code class="nohighlight hljs">deviance(model::StatisticalModel)</code></pre><p>Return the deviance of the model relative to a reference, which is usually when applicable the saturated model. It is equal, <em>up to a constant</em>, to <span>$-2 \log L$</span>, with <span>$L$</span> the likelihood of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.nulldeviance" href="#StatsBase.nulldeviance"><code>StatsBase.nulldeviance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nulldeviance(obj::LinearModel)</code></pre><p>For linear models, the deviance of the null model is equal to the total sum of squares (TSS).</p></div></section><section><div><pre><code class="nohighlight hljs">nulldeviance(model::StatisticalModel)</code></pre><p>Return the deviance of the null model, that is the one including only the intercept.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.dof" href="#StatsBase.dof"><code>StatsBase.dof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dof(model::StatisticalModel)</code></pre><p>Return the number of degrees of freedom consumed in the model, including when applicable the intercept and the distribution&#39;s dispersion parameter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.dof_residual" href="#StatsBase.dof_residual"><code>StatsBase.dof_residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dof_residual(model::RegressionModel)</code></pre><p>Return the residual degrees of freedom of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.nobs-Tuple{StatisticalModel}" href="#StatsBase.nobs-Tuple{StatisticalModel}"><code>StatsBase.nobs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nobs(model::StatisticalModel)</code></pre><p>Return the number of independent observations on which the model was fitted. Be careful when using this information, as the definition of an independent observation may vary depending on the model, on the format used to pass the data, on the sampling plan (if specified), etc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.isfitted" href="#StatsBase.isfitted"><code>StatsBase.isfitted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isfitted(model::StatisticalModel)</code></pre><p>Indicate whether the model has been fitted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.islinear" href="#StatsBase.islinear"><code>StatsBase.islinear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">islinear(model::StatisticalModel)</code></pre><p>Indicate whether the model is linear.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.loglikelihood" href="#StatsBase.loglikelihood"><code>StatsBase.loglikelihood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loglikelihood(model::StatisticalModel)</code></pre><p>Return the log-likelihood of the model.</p></div></section><section><div><pre><code class="nohighlight hljs">loglikelihood(model::StatisticalModel, ::Colon)</code></pre><p>Return a vector of each observation&#39;s contribution to the log-likelihood of the model. In other words, this is the vector of the pointwise log-likelihood contributions.</p><p>In general, <code>sum(loglikehood(model, :)) == loglikelihood(model)</code>.</p></div></section><section><div><pre><code class="nohighlight hljs">loglikelihood(model::StatisticalModel, observation)</code></pre><p>Return the contribution of <code>observation</code> to the log-likelihood of <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.nullloglikelihood" href="#StatsBase.nullloglikelihood"><code>StatsBase.nullloglikelihood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loglikelihood(model::StatisticalModel)</code></pre><p>Return the log-likelihood of the null model corresponding to <code>model</code>. This is usually the model containing only the intercept.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.stderror" href="#StatsBase.stderror"><code>StatsBase.stderror</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stderror(model::StatisticalModel)</code></pre><p>Return the standard errors for the coefficients of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.vcov" href="#StatsBase.vcov"><code>StatsBase.vcov</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vcov(model::StatisticalModel)</code></pre><p>Return the variance-covariance matrix for the coefficients of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.weights" href="#StatsBase.weights"><code>StatsBase.weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weights(vs)</code></pre><p>Construct a <code>Weights</code> vector from array <code>vs</code>. See the documentation for <a href="@ref"><code>Weights</code></a> for more details.</p></div></section><section><div><pre><code class="nohighlight hljs">weights(model::StatisticalModel)</code></pre><p>Return the weights used in the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.workingweights" href="#RobustModels.workingweights"><code>RobustModels.workingweights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">workingweights(m::RobustLinearModel)</code></pre><p>The robust weights computed by the model.</p><p>This can be used to detect outliers, as outliers weights are lower than the weights of valid data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fitted" href="#StatsBase.fitted"><code>StatsBase.fitted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitted(model::RegressionModel)</code></pre><p>Return the fitted values of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.predict" href="#StatsBase.predict"><code>StatsBase.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predict(model::RegressionModel, [newX])</code></pre><p>Form the predicted response of <code>model</code>. An object with new covariate values <code>newX</code> can be supplied, which should have the same type and structure as that used to fit <code>model</code>; e.g. for a GLM it would generally be a <code>DataFrame</code> with the same variable names as the original predictors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.leverage" href="#StatsBase.leverage"><code>StatsBase.leverage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leverage(model::RegressionModel)</code></pre><p>Return the diagonal of the projection matrix of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.modelmatrix" href="#StatsBase.modelmatrix"><code>StatsBase.modelmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelmatrix(model::RegressionModel)</code></pre><p>Return the model matrix (a.k.a. the design matrix).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.projectionmatrix" href="#RobustModels.projectionmatrix"><code>RobustModels.projectionmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">projectionmatrix(m::RobustLinearModel)</code></pre><p>The robust projection matrix from the predictor: X (X&#39; W X)⁻¹ X&#39; W</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/linpred.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GLM.dispersion-Tuple{RobustLinearModel, Bool}" href="#GLM.dispersion-Tuple{RobustLinearModel, Bool}"><code>GLM.dispersion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispersion(m::RobustLinearModel, sqr::Bool=false)</code></pre><p>The dispersion is the (weighted) sum of robust residuals. If <code>sqr</code> is true, return the squared dispersion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.response" href="#StatsBase.response"><code>StatsBase.response</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">response(model::RegressionModel)</code></pre><p>Return the model response (a.k.a. the dependent variable).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.residuals" href="#StatsBase.residuals"><code>StatsBase.residuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">residuals(model::RegressionModel)</code></pre><p>Return the residuals of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.scale" href="#RobustModels.scale"><code>RobustModels.scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale(m::RobustLinearModel, sqr::Bool=false)</code></pre><p>The robust scale estimate used for the robust estimation.</p><p>If <code>sqr</code> is <code>true</code>, the square of the scale is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.tauscale" href="#RobustModels.tauscale"><code>RobustModels.tauscale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tauscale(m::RobustLinearModel, sqr::Bool=false; kwargs...)</code></pre><p>The robust τ-scale that is minimized in τ-estimation.</p><p>If <code>sqr</code> is <code>true</code>, the square of the τ-scale is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.location_variance" href="#RobustModels.location_variance"><code>RobustModels.location_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">location_variance(r::RobustLinResp, sqr::Bool=false)</code></pre><p>Compute the part of the variance of the coefficients <code>β</code> that is due to the encertainty from the location. If <code>sqr</code> is <code>false</code>, return the standard deviation instead.</p><p>From Maronna et al., Robust Statistics: Theory and Methods, Equation 4.49</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/linresp.jl#L173-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.Estimator" href="#RobustModels.Estimator"><code>RobustModels.Estimator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Estimator(m::RobustLinearModel)</code></pre><p>The robust estimator object used to fit the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/robustlinearmodel.jl#L134-L138">source</a></section></article><h2 id="Estimators"><a class="docs-heading-anchor" href="#Estimators">Estimators</a><a id="Estimators-1"></a><a class="docs-heading-anchor-permalink" href="#Estimators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobustModels.MEstimator" href="#RobustModels.MEstimator"><code>RobustModels.MEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MEstimator{L&lt;:LossFunction} &lt;: AbstractEstimator</code></pre><p>M-estimator for a given loss function.</p><p>The M-estimator is obtained by minimizing the loss function:</p><p class="math-container">\[\hat{\mathbf{\beta}} = \underset{\mathbf{\beta}}{\textrm{argmin}} \sum_{i=1}^n \rho\left(\dfrac{r_i}{\hat{\sigma}}\right)\]</p><p>with the residuals  <span>$\mathbf{r} = \mathbf{y} - \mathbf{X} \mathbf{\beta}$</span> , and a robust scale estimate <span>$\hat{\sigma}$</span>.</p><p><strong>Fields</strong></p><ul><li><code>loss</code>: the <a href="#RobustModels.LossFunction"><code>LossFunction</code></a> used for the robust estimation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L731-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.L1Estimator" href="#RobustModels.L1Estimator"><code>RobustModels.L1Estimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>L1Estimator</code> is a shorthand name for <code>MEstimator{L1Loss}</code>. Using exact QuantileRegression should be prefered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.L2Estimator" href="#RobustModels.L2Estimator"><code>RobustModels.L2Estimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>L2Estimator</code> is a shorthand name for <code>MEstimator{L2Loss}</code>, the non-robust OLS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.SEstimator" href="#RobustModels.SEstimator"><code>RobustModels.SEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SEstimator{L&lt;:BoundedLossFunction} &lt;: AbstractEstimator</code></pre><p>S-estimator for a given bounded loss function.</p><p>The S-estimator is obtained by minimizing the scale estimate:</p><p class="math-container">\[\hat{\mathbf{\beta}} = \underset{\mathbf{\beta}}{\textrm{argmin }} \hat{\sigma}^2\]</p><p>where the robust scale estimate <span>$\hat{\sigma}}$</span> is solution of:</p><p class="math-container">\[\dfrac{1}{n} \sum_{i=1}^n \rho\left(\dfrac{r_i}{\hat{\sigma}}\right) = \delta\]</p><p>with the residuals  <span>$\mathbf{r} = \mathbf{y} - \mathbf{X} \mathbf{\beta}$</span> , <span>$\rho$</span> is a bounded loss function with  <span>$\underset{r \to \infty}{\lim} \rho(r) = 1$</span> and <span>$\delta$</span> is the finite breakdown point, usually 0.5.</p><p><strong>Fields</strong></p><ul><li><code>loss</code>: the <a href="#RobustModels.LossFunction"><code>LossFunction</code></a> used for the robust estimation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L789-L815">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.MMEstimator" href="#RobustModels.MMEstimator"><code>RobustModels.MMEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MMEstimator{L1&lt;:BoundedLossFunction, L2&lt;:LossFunction} &lt;: AbstractEstimator</code></pre><p>MM-estimator for the given loss functions.</p><p>The MM-estimator is obtained using a two-step process:</p><ol><li>compute a robust scale estimate with a high breakdown point using a S-estimate and the loss function <code>L1</code>.</li><li>compute an efficient estimate using a M-estimate with the loss function <code>L2</code>.</li></ol><p><strong>Fields</strong></p><ul><li><code>loss1</code>: the <a href="@ref"><code>BoundedLossFunction</code></a> used for the high breakdown point S-estimation.</li><li><code>loss2</code>: the <a href="#RobustModels.LossFunction"><code>LossFunction</code></a> used for the efficient M-estimation.</li><li><code>scaleest</code>: boolean specifying the if the estimation is in the S-estimation step (<code>true</code>)</li></ul><p>or the M-estimation step (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L849-L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.TauEstimator" href="#RobustModels.TauEstimator"><code>RobustModels.TauEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TauEstimator{L1&lt;:BoundedLossFunction, L2&lt;:BoundedLossFunction} &lt;: AbstractEstimator</code></pre><p>τ-estimator for the given loss functions.</p><p>The τ-estimator corresponds to a M-estimation, where the loss function is a weighted sum of a high breakdown point loss and an efficient loss. The weight is recomputed at every step of the Iteratively Reweighted Least Square, so the estimate is both robust (high breakdown point) and efficient.</p><p><strong>Fields</strong></p><ul><li><code>loss1</code>: the high breakdown point <a href="@ref"><code>BoundedLossFunction</code></a>.</li><li><code>loss2</code>: the high efficiency <a href="@ref"><code>BoundedLossFunction</code></a>.</li><li><code>w</code>: the weight in the sum of losses: <code>w . loss1 + loss2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L933-L949">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.GeneralizedQuantileEstimator" href="#RobustModels.GeneralizedQuantileEstimator"><code>RobustModels.GeneralizedQuantileEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedQuantileEstimator{L&lt;:LossFunction} &lt;: AbstractQuantileEstimator</code></pre><p>Generalized Quantile Estimator is an M-Estimator with asymmetric loss function.</p><p>For <a href="#RobustModels.L1Loss"><code>L1Loss</code></a>, this corresponds to quantile regression (although it is better to use <a href="#RobustModels.quantreg"><code>quantreg</code></a> for quantile regression because it gives the exact solution).</p><p>For <a href="#RobustModels.L2Loss"><code>L2Loss</code></a>, this corresponds to Expectile regression (see <a href="#RobustModels.ExpectileEstimator"><code>ExpectileEstimator</code></a>).</p><p><strong>Fields</strong></p><ul><li><code>loss</code>: the <a href="#RobustModels.LossFunction"><code>LossFunction</code></a>.</li><li><code>τ</code>: the quantile value to estimate, between 0 and 1.</li></ul><p><strong>Properties</strong></p><ul><li><code>tau</code>, <code>q</code>, <code>quantile</code> are aliases for <code>τ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L1124-L1140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.ExpectileEstimator" href="#RobustModels.ExpectileEstimator"><code>RobustModels.ExpectileEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The expectile estimator is a generalization of the L2 estimator, for other quantile τ ∈ [0,1].</p><p>[1] Schnabel, Eilers - Computational Statistics and Data Analysis 53 (2009) 4168–4177 - Optimal expectile smoothing doi:10.1016/j.csda.2009.05.002</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L1210-L1215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.QuantileEstimator" href="#RobustModels.QuantileEstimator"><code>RobustModels.QuantileEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Non-exact quantile estimator, <code>GeneralizedQuantileEstimator{L1Loss}</code>. Prefer using <a href="#RobustModels.QuantileRegression"><code>QuantileRegression</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L1218">source</a></section></article><h2 id="Loss-functions"><a class="docs-heading-anchor" href="#Loss-functions">Loss functions</a><a id="Loss-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobustModels.L2Loss" href="#RobustModels.L2Loss"><code>RobustModels.L2Loss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The (convex) L2 loss function is that of the standard least squares problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.L1Loss" href="#RobustModels.L1Loss"><code>RobustModels.L1Loss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The standard L1 loss function takes the absolute value of the residual, and is convex but non-smooth. It is not a real L1 loss but a Huber loss with very small tuning constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.HuberLoss" href="#RobustModels.HuberLoss"><code>RobustModels.HuberLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The convex Huber loss function switches from between quadratic and linear cost/loss function at a certain cutoff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L202-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.L1L2Loss" href="#RobustModels.L1L2Loss"><code>RobustModels.L1L2Loss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The convex L1-L2 loss interpolates smoothly between L2 behaviour for small residuals and L1 for outliers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L231-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.FairLoss" href="#RobustModels.FairLoss"><code>RobustModels.FairLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The (convex) &quot;fair&quot; loss switches from between quadratic and linear cost/loss function at a certain cutoff, and is C3 but non-analytic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L254-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.LogcoshLoss" href="#RobustModels.LogcoshLoss"><code>RobustModels.LogcoshLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The convex Log-Cosh loss function log(cosh(r))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L276-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.ArctanLoss" href="#RobustModels.ArctanLoss"><code>RobustModels.ArctanLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The convex Arctan loss function r * arctan(r) - 1/2*log(1 + r^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L299-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.CauchyLoss" href="#RobustModels.CauchyLoss"><code>RobustModels.CauchyLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The non-convex Cauchy loss function switches from between quadratic behaviour to logarithmic tails. This rejects outliers but may result in multiple minima. For scale estimate, r.ψ(r) is used as a loss, which is the same as for Geman loss.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.GemanLoss" href="#RobustModels.GemanLoss"><code>RobustModels.GemanLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The non-convex Geman-McClure for strong supression of outliers and does not guarantee a unique solution. For the S-Estimator, it is equivalent to the Cauchy loss.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L352-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.WelschLoss" href="#RobustModels.WelschLoss"><code>RobustModels.WelschLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The non-convex Welsch for strong supression of ourliers and does not guarantee a unique solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L381-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.TukeyLoss" href="#RobustModels.TukeyLoss"><code>RobustModels.TukeyLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The non-convex Tukey biweight estimator which completely suppresses the outliers, and does not guaranty a unique solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L408-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.YohaiZamarLoss" href="#RobustModels.YohaiZamarLoss"><code>RobustModels.YohaiZamarLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The non-convex (and bounded) optimal Yohai-Zamar loss function that minimizes the estimator bias. It was originally introduced in Optimal locally robust M-estimates of regression (1997) by Yohai and Zamar with a slightly different formula.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L435-L440">source</a></section></article><h2 id="Estimator-and-Loss-functions-methods"><a class="docs-heading-anchor" href="#Estimator-and-Loss-functions-methods">Estimator and Loss functions methods</a><a id="Estimator-and-Loss-functions-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Estimator-and-Loss-functions-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobustModels.rho" href="#RobustModels.rho"><code>RobustModels.rho</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The loss function ρ for the M-estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.psi" href="#RobustModels.psi"><code>RobustModels.psi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The influence function ψ is the derivative of the loss function for the M-estimator, multiplied by the square of the tuning constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.psider" href="#RobustModels.psider"><code>RobustModels.psider</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The derivative of ψ, used for asymptotic estimates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.weight" href="#RobustModels.weight"><code>RobustModels.weight</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The weights for IRLS, the function ψ divided by r.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.values" href="#RobustModels.values"><code>RobustModels.values</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Faster version if you need ρ, ψ and w in the same call</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.estimator_norm" href="#RobustModels.estimator_norm"><code>RobustModels.estimator_norm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The integral of exp(-ρ) used for calculating the full-loglikelihood</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.estimator_bound" href="#RobustModels.estimator_bound"><code>RobustModels.estimator_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The limit at ∞ of the loss function. Used for scale estimation of bounded loss.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.tuning_constant" href="#RobustModels.tuning_constant"><code>RobustModels.tuning_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The tuning constant of the loss function, can be optimized to get efficient or robust estimates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.isconvex" href="#RobustModels.isconvex"><code>RobustModels.isconvex</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Boolean if the estimator or loss function is convex</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.isbounded" href="#RobustModels.isbounded"><code>RobustModels.isbounded</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Boolean if the estimator or loss function is bounded</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.estimator_high_breakdown_point_constant" href="#RobustModels.estimator_high_breakdown_point_constant"><code>RobustModels.estimator_high_breakdown_point_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The tuning constant associated to the loss that gives an efficient M-estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.estimator_high_efficiency_constant" href="#RobustModels.estimator_high_efficiency_constant"><code>RobustModels.estimator_high_efficiency_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The tuning constant associated to the loss that gives a robust (high breakdown point) M-estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.efficient_loss" href="#RobustModels.efficient_loss"><code>RobustModels.efficient_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The loss initialized with an efficient tuning constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.robust_loss" href="#RobustModels.robust_loss"><code>RobustModels.robust_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The loss initialized with a robust (high breakdown point) tuning constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.efficiency_tuning_constant" href="#RobustModels.efficiency_tuning_constant"><code>RobustModels.efficiency_tuning_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The tuning constant c is computed so the efficiency for Normal distributed residuals is 0.95. The efficiency of the mean estimate μ is defined by:</p><p>eff_μ = (E[ψ&#39;])²/E[ψ²]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.mscale_loss" href="#RobustModels.mscale_loss"><code>RobustModels.mscale_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mscale_loss(loss::L, x)</code></pre><p>The rho-function that is used for M-scale estimation.</p><p>For monotone (convex) functions, χ(r) = r.ψ(r).</p><p>For bounded functions, χ(r) = ρ(r)/ρ(∞) so χ(∞) = 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L125-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.breakdown_point_tuning_constant" href="#RobustModels.breakdown_point_tuning_constant"><code>RobustModels.breakdown_point_tuning_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The M-estimate of scale is computed by solving:</p><p class="math-container">\[\dfrac{1}{n} \sum_i \chi\left( \dfrac{r_i}{\hat{\sigma}}\right) = \delta\]</p><p>For monotone (convex) functions, χ(r) = r.ψ(r) and δ is defined as E[χ(r)] = δ for the Normal distribution N(0,1) For bounded functions, χ(r) = ρ(r)/ρ(∞) with χ(∞) = 1 and δ = E[χ]/χ(∞) with expectation w.r.t. Normal density.</p><p>The tuning constant c corresponding to a high breakdown point (0.5) is such that δ = 1/2, from  1/n Σ χ(r/ŝ) = δ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L139-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.scale_estimate" href="#RobustModels.scale_estimate"><code>RobustModels.scale_estimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_estimate(loss, res; σ0=1.0, wts=[], verbose=false,
                         order=1, approx=false, nmax=30,
                         rtol=1e-4, atol=0.1)</code></pre><p>Compute the M-scale estimate from the loss function. If the loss is bounded, ρ is used as the function χ in the sum, otherwise r.ψ(r) is used if the loss is not bounded, to coincide with the Maximum Likelihood Estimator. Also, for bounded estimator, because f(s) = 1/(nδ) Σ ρ(ri/s) is decreasing the iteration step is not using the weights but is multiplicative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L567-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.tau_efficiency_tuning_constant" href="#RobustModels.tau_efficiency_tuning_constant"><code>RobustModels.tau_efficiency_tuning_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tau_efficiency_tuning_constant(::Type{L1}, ::Type{L2}; eff::Real=0.95, c0::Real=1.0)
    where {L1&lt;:BoundedLossFunction,L2&lt;:BoundedLossFunction}</code></pre><p>Compute the tuning constant that corresponds to a high breakdown point for the τ-estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L992-L997">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.estimator_tau_efficient_constant" href="#RobustModels.estimator_tau_efficient_constant"><code>RobustModels.estimator_tau_efficient_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The tuning constant associated to the loss that gives a robust τ-estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L1029">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.loss" href="#RobustModels.loss"><code>RobustModels.loss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The loss function used for the estimation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.set_SEstimator" href="#RobustModels.set_SEstimator"><code>RobustModels.set_SEstimator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>MEstimator, set to S-Estimation phase</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.set_MEstimator" href="#RobustModels.set_MEstimator"><code>RobustModels.set_MEstimator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>MEstimator, set to M-Estimation phase</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.update_weight!" href="#RobustModels.update_weight!"><code>RobustModels.update_weight!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_weight!(E::TauEstimator, res::AbstractArray{T}; wts::AbstractArray{T}=T[])</code></pre><p>Update the weight between the two estimators of a τ-estimator using the scaled residual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L1036-L1040">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.tau_scale_estimate" href="#RobustModels.tau_scale_estimate"><code>RobustModels.tau_scale_estimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tau_scale_estimate!(E::TauEstimator, res::AbstractArray{T}, σ::Real, sqr::Bool=false;
                    wts::AbstractArray{T}=T[], bound::AbstractFloat=0.5) where {T&lt;:AbstractFloat}</code></pre><p>The τ-scale estimate, where <code>σ</code> is the scale estimate from the robust M-scale. If <code>sqr</code> is true, return the squared value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L1087-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobustModels.quantile_weight" href="#RobustModels.quantile_weight"><code>RobustModels.quantile_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quantile_weight(τ::Real, r::Real)</code></pre><p>Wrapper function to compute quantile-like loss function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/getzze/RobustModels.jl/blob/34bb17b9d7a415fd9ade015b1dfe31a2c9847210/src/estimators.jl#L1117-L1121">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 22 October 2021 18:11">Friday 22 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
